FJ inference
program ::= Ds
D   ::= interface C[Xs] { fMs , FMHs }
FMH ::= m[Xs](x1:FT1 .. xn:FTn):FT
fM  ::= FMH { return fe }
cM  ::= FMH { return ce }
M   ::= MH { return e  }
FT  ::= C[FTs] | X
T   ::= C[Ts]  | X | ? | Err
fe  ::= x | new C[FTs](){ fMs } | fe.m[FTs](fes) | fe.m(fes) | xs -> fe
ce  ::= x   | new C[FTs](){ cMs } | ce.m[FTs](ces)
e   ::= x:T | new C[Ts](){ Ms }:T | e.m[Ts](es):T | (xs->e):T | e.m(es):T
Γ   ::= x1:T1  .. xn:Tn
//Note: in this restricted language the anon inner class can ONLY define methods in C (not new ones)
Pipeline for every method body
containing a full-expression fe under Γ (including 'this') with return FT

- e := inferenceOf(fe, FT)
- Γ ⊢ e ==>* Γ' ⊢ e' //Γ and FT extracted from the method signature
- lower(fe,e') = ce
- Γ ⊢ ce : FT //finally, typing the method body

Obvious selectors:
- typeOf(e) = T
- withType(e,T) = e'
- methodHeader(T,m) = Ts; C[Xs]; m[Xs'](x1 : T1 .. xn : Tn) : T0
- methodHeader(e,m)= methodHeader(typeOf(e),m)
//Note: methodHeader(C[Ts],m) do not already apply [Xs=Ts], instead produces a triple
//Ts;C[Xs]; m[Xs'](..) that are ready to use in the needed context using appropriate alpha renaming
//Here Ts is returned even if part of the input for convenience, so other parts of the rules can just use it

Substitution: T[Xs=Ts] //standard
_______
#Define T ⊓ T' = T" and Ts ⊓ Ts' = Ts" //meet operator
- (T1..Tn) ⊓ (T'1..T'n) = (T1⊓T'1 .. Tn⊓T'n)
- ? ⊓ T = T
- T ⊓ ? = T
- X ⊓ X = X
- C[Ts] ⊓ C[Ts'] = C[Ts⊓Ts']
- T ⊓ T' = Err otherwise //that, meet is always defined
_______
#Define e ⊓ T = e'
  withType(e,typeOf(e) ⊓ T)
_______
#Define Xs ⊢ T=T' : Ts' //sub notation used in (refine)

//Rule (refineXs) STARTS HERE
---------------------------------------------------(refineXs)
  X1..Xn X X'1..X'k ⊢ X=T : ?1..?n T ?1..?k
  //selects an X inside Xs' by splitting Xs' as X1..Xn X X1'..Xk'
//Rule (refineXsNope) STARTS HERE
  X notin X1..Xn //can happen when we refine class generics and method generics are in scope
---------------------------------------------------(refineXsNope)
  X1..Xn ⊢ X=T : ?1..?n
//Rule (refine?) STARTS HERE
---------------------------------------------------(refine?)
  X1..Xn⊢ ?=T : ?1..?n
//Rule (refineErr) STARTS HERE
---------------------------------------------------(refineErr)
  X1..Xn⊢ Err=T : ?1..?n
//Rule (propagateXs) STARTS HERE
  ∀ i∈1..k Xs ⊢ Ti=T'i  : Tsi 
--------------------------------------------------(propagateXs)
  X1..Xn ⊢ C[T1..Tk]=C[T'1..T'k] : ?1..?n⊓Ts1⊓..⊓Tsk
  //the first ?s are needed if n==0
//Rule (propagateXs?) STARTS HERE
--------------------------------------------------(propagateXs?)
  X1..Xn ⊢ C[Ts]=? : ?1..?n
//Rule (propagateXsErr) STARTS HERE
--------------------------------------------------(propagateXsErr)
  X1..Xn ⊢ C[Ts]=Err : ?1..?n
//Rule (propagateXsDiff) STARTS HERE
  either C != C' or size(Ts) != size(Ts')   
--------------------------------------------------(propagateXsDiff)
  X1..Xn ⊢ C[Ts]=C'[Ts'] : ?1..?n

_______
#Define Γ ⊢ e ==>* Γ' ⊢ e' //read as reduce as much as possible
  Γ ⊢ e ==>* Γ ⊢ e if ¬∃ Γ',e' such that Γ ⊢ e ==> Γ' ⊢ e' 
  Γ ⊢ e ==>* Γ ⊢ e if Γ ⊢ e ==> Γ ⊢ e
  Γ ⊢ e ==>* Γ" ⊢ e" if Γ ⊢ e ==> Γ' ⊢ e' and Γ' ⊢ e' ==>* Γ" ⊢ e"   
  //and Γ', e' != Γ, e
_______
#Define Γ ⊢ e ==> Γ' ⊢ e'

//Rule (x) STARTS HERE
-------------------------------------- (x)     //loop handled by ==>*
  Γ, x:T1 ⊢ x:T2 ==> Γ, x:T1 ⊓ T2 ⊢ x:T1 ⊓ T2
//Rule (call) STARTS HERE
  ∀ i∈0..n Γi ⊢ ei ==>* Γ(i+1) ⊢ e'i
  methodHeader(e'0,m) undefined
  // may be because typeOf(e'0) not of form C[_], or m not exists in C[_]
-------------------------------------- (call)
  Γ0 ⊢ e0.m(e1..en):T ==> Γ(n+1) ⊢ e'0.m(e'1..e'n):T
//Rule (callI) STARTS HERE
  ∀ i∈0..n Γi ⊢ ei ==>* Γ(i+1) ⊢ e'i
  methodHeader(e'0,m) = Ts;C[Xs]; m[X1..Xk](_:T1.._:Tn):T0
  ∀ i∈0..n T'i = Ti[Xs,X1..Xk=Ts;?1..?k]//Changed HERE
-------------------------------------- (callI)
  Γ0 ⊢ e0.m(e1..en):T ==> Γ(n+1) ⊢ e'0.m[?1..?k](e'1⊓T'1..e'n⊓T'n):T⊓T'0
//Rule (callRNope) STARTS HERE
  ∀ i∈0..n Γi ⊢ ei ==>* Γ(i+1) ⊢ e'i
  methodHeader(e'0,m) undefined
----------------------------------------------------------- (callRNope)
  Γ0 ⊢ e0.m[Ts](e1..en):T ==> Γ(n+1) ⊢ e'0.m[Ts](e'1..e'n):T
//Rule (callR) STARTS HERE
  ∀ i∈0..n Γi ⊢ ei ==>* Γ(i+1) ⊢ e'i
  methodHeader(e'0,m) = Ts'; C[Xs]; m[Xs'](_:T1.._:Tn):T0
  ∀ i∈1..n Xs,Xs' ⊢ Ti=typeOf(e'i) : Ts'i//args
  Xs,Xs' ⊢ T0=T : Ts'0 //ret type
  Ts" = (Ts';Ts) ⊓ Ts'0 ⊓ .. ⊓ Ts'n
  ∀ i∈0..n T"i = Ti[Xs,Xs'=Ts"]
  T" = C[Xs][Xs,Xs'=Ts"]
----------------------------------------------------------- (callR)
  Γ0 ⊢ e0.m[Ts](e1..en):T ==> Γ(n+1) ⊢ e'0⊓T".m[Xs'[Xs,Xs'=Ts"]](e'1⊓T"1..e'n⊓T"n):T⊓T"0
//Rule (lambda) STARTS HERE
  m is the only abs meth of C with n parameters
  methodHeader(C[Ts],m)= Ts; C[Xs]; m[Xs'](_:T1.._:Tn):T0
  M = m[Xs'](x1:T1[Xs=Ts] .. xn:Tn[Xs=Ts]): T0[Xs=Ts] { return e0⊓T0[Xs=Ts]; }
  //NOTE: 'this' changes scope here, how to handle it?
----------------------------------------------------------- (lambda)
  Γ ⊢ (x1..xn->e0) : C[Ts] ==> Γ ⊢ new C[Ts](){ M }:C[Ts]
//Rule (lambdaNope) STARTS HERE
  there is no m with n parameters that is the only abs meth of C
----------------------------------------------------------- (lambdaNope)
  Γ ⊢ (x1..xn->e0) : C[Ts] ==> Γ ⊢ (x1..xn->e0) : C[Ts]
//Rule (anon) STARTS HERE
  e1 = new C[Ts1    ](){ M1 ..Mn  } : C[Ts1    ]
  e2 = new C[Ts(n+1)](){ M'1..M'n } : C[Ts(n+1)]
  ∀ i∈1..n  Γi;C[Tsi] ⊢ Mi ==>* Γ(i+1);C[Ts(i+1)] ⊢ M'i
----------------------------------------------------------- (anon)
  Γ1 ⊢ e1 ==> Γ(n+1) ⊢ e2
//Rule (meth) STARTS HERE
  M  = m[Xs](x1:T1 .. xn:Tn):_ { return e; }
  Γ, this:C[Ts],x1:T1 .. xn:Tn⊢ e ==>* Γ',this:_,x1:T'1 .. xn:T'n ⊢ e'
  T'0 = typeOf(e')
  interface C[Xs'] { _ m[Xs](_:FT1 .. _:FTn):FT0 _ } in Ds
  forall i in 0..n Xs' |- FTi=T'i : Tsi
  Ts' = Ts⊓Ts0⊓..⊓Tsn
  methodHeader(C[Ts'],m) =Ts'; C[Xs']; m[Xs](_:T"1.._:T"n):T"0
  M' = m[Xs](x1:T'1⊓T"1[Xs'=Ts'] .. xn:T'n⊓T"n[Xs'=Ts']):T'0⊓T"0[Xs'=Ts'] { return e'⊓T"0[Xs'=Ts']; }
------------------------------------------------------------------ (meth)
  Γ;C[Ts] ⊢ M ==>* Γ';C[Ts'] ⊢ M'
//Note: in a more complete language we should consider the case where
//methodHeader(C[Ts],m) is undefined; for example, m is new in this anon

//-------------------------------- less then 150 lines of formalism
TODO: formally define angelicElaborate and the statement
Ds |- angelicElaborate(Γ,fe,T,ce)
TODO: read https://kelloggm.github.io/martinjkellogg.com/papers/ase2023-camera-ready.pdf
if there is a unique elaboration, my system finds it
(x)->e: F[A,B] MyF[A,B]
MyF[A,B]:F[A,B]{}

//(xs)->e:? if this cannot be unlocked, we never enter into e

_______
#Define Γ ⊢/ e //read as Γ,e does not reduce (unused)
  ¬∃ Γ',e'.(Γ ⊢ e ==> Γ' ⊢ e')

Optimizing (avoiding) re entries://not quite working?
Once a Γ ⊢ e ==>* Γ' ⊢ e' completed,
we know that Γ" ⊢ e' ==>* Γ" ⊢ e' if: //that is, no progress
  Γ0 = FV(e') //gets a gamma since syntax has x:T
  ∀ x in dom(Γ0) Γ0(x) = Γ"(x)
This also means that
Once a Γ ⊢ e ==>* Γ' ⊢ ev completed, Γ" ⊢ ev ==>* Γ1 ⊢ ev' can be emulated by:
 Γ0 = FV(ev) and ev = ev'
 Γ1 = Γ0 ⊓ Γ"


//On the (not) need of alpha: if no need of alpha in methSig (since two universes)
//then the X1..Xk is still not alphaed, thus is still the same of what methSig can give us here?